#
# Renjin : JVM-based interpreter for the R language for the statistical analysis
# Copyright © 2010-2018 BeDataDriven Groep B.V. and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, a copy is available at
# https://www.gnu.org/licenses/gpl-2.0.txt
#

# Common functions for generating
# test cases

header <- paste(c(
  "#",
  "# Renjin : JVM-based interpreter for the R language for the statistical analysis",
  "# Copyright © 2010-2016 BeDataDriven Groep B.V. and contributors",
  "#",
  "# This program is free software; you can redistribute it and/or modify",
  "# it under the terms of the GNU General Public License as published by",
  "# the Free Software Foundation; either version 2 of the License, or",
  "# (at your option) any later version.",
  "#",
  "# This program is distributed in the hope that it will be useful,",
  "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
  "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
  "# GNU General Public License for more details.",
  "#",
  "# You should have received a copy of the GNU General Public License",
  "# along with this program; if not, a copy is available at",
  "# https://www.gnu.org/licenses/gpl-2.0.txt",
  "#"), collapse="\n")

deparse0 <- function(x)
    paste(deparse(x,
        control = c("showAttributes", "keepInteger", "keepNA")), collapse = "")

deparseExpected <- function(x) {
   if(typeof(x) == "language") {
    sprintf("quote(%s)", deparse0(x))
   } else if(typeof(x) == "expression") {
    sprintf("as.expression(%s)", deparse0(as.list(x)))
   } else if(typeof(x) == "symbol") {
    sprintf("as.name(%s)", deparse0(x))
   } else {
    if(typeof(x) == "list") {
      for(i in seq_along(x)) {
        if(typeof(x[[i]]) == "symbol") {
          x[[i]] <- call("quote", x[[i]])
        }
      }  
    }
    deparse0(x)
   }
}

is.small.integral <- function(x) {
  if(is.double(x)) {
    finite <- x[is.finite(x)]
    frac <- finite %% 1
  
    return(all(abs(finite) < 2^29) && all(frac == 0))
  
  } else {
    return(FALSE)
  }
}

callWithQuotedArgs <- function(fn, args) {
  stopifnot(is.list(args))
  call <- as.call(c(as.name(fn), args))
  if(length(call) > 1) {
    for(i in seq.int(from = 2, to = length(call))) {
      arg <- call[[i]]
      if(typeof(arg) == "symbol" || typeof(arg) == "language") {
        call[[i]] <- call("quote", arg)
      } 
    }
  }
  call
}

literal <- function(x) {
  stopifnot(is.character(x))
  class(x) <- "literal"
  x
}

test.open <- function(generatorScript, name) {
  filename <- sprintf("src/test/R/test.%s.R", name)
  cat(sprintf("Opening test case %s...\n", filename))
  test <- new.env()
  test$fd <- file(filename, open="w")
  test$index <- 1
  class(test) <- "test"
  writeln(test, header)
  writeln(test, "")
  writeln(test, "# Generated by %s using GNU %s",
          generatorScript, R.Version()$version.string)
  test
} 

writeln <- function(test, format, ...) {
  writeLines(test$fd, text = sprintf(format, ...))
}

writeFixture <- function(test, format, ...) {
  if(missing(...)) {
    expr <- as.character(format)
  } else{
    expr <- sprintf(format, ...)
  }
  writeLines(test$fd, text = expr)
  eval(parse(text = expr), envir = .GlobalEnv)
}

writeTest <- function(test, fn, ..., ARGS, tol = NULL, SET.SEED = FALSE, TEST.NAME = fn) {
  call <- callWithQuotedArgs(fn, if(missing(ARGS)) list(...) else ARGS)
  if (SET.SEED) {
    set.seed(1)
  }

  expected <- tryCatch(eval(call, envir = .GlobalEnv), error = function(e) e)

  if(inherits(expected, "error")) {
    matcher <- "throwsError()"
    
  } else if(typeof(expected) == "symbol") {
    matcher <- sprintf("identicalTo(as.name(%s))", deparse(as.character(expected)))
    
  } else if(typeof(expected) %in% c("language", "expression")) {
    matcher <- sprintf("deparsesTo(%s)", deparse0(deparse0(expected)))
  
  } else if(is.null(tol) || !is.double(expected) || is.small.integral(expected)) {
    matcher <- sprintf("identicalTo(%s)", deparseExpected(expected))
    
  } else {
    matcher <- sprintf("identicalTo(%s, tol = %f)", deparseExpected(expected), tol)
  }
  
  if(SET.SEED) {
    writeln(test, "test.%s.%d <- function() { set.seed(1); assertThat(%s, %s) }",
            TEST.NAME, test$index, deparse0(call), matcher)
    
  } else {
    writeln(test, "test.%s.%d <- function() assertThat(%s, %s)",
            TEST.NAME, test$index, deparse0(call), matcher)
    
  }
  test$index <- test$index + 1
}

close.test <- function(test) {
  close(test$fd)
}

